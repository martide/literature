defmodule Literature.StaticPages.Generator do
  @moduledoc """
  Defines a static page generator for a given publication. Provides a set of macros and functions to automate the generation of static pages such as index, paginated index, tags, authors, and show pages for a publication(see `Available Pages`). It supports customization through options, including which pages to generate, pagination size, output path, and custom templates. Static pages are stored in the `priv/static` directory of the application.

  ## Usage

      use Literature.StaticPages.Generator,
        only: ~w(index index_page show_post tags authors)a,
        path: "/en",
        publication_slug: "blog",
        templates: Literature.StaticPages.Templates,
        page_size: 10,

  ## Options

    * `:only` - List of page types to generate (default: `~w(index show tags authors)a`).
    * `:page_size` - Number of posts per page for paginated pages (default: `10`).
    * `:path` - Base path for generated static files (default: `"/"`).
    * `:publication_slug` (required) - The slug of the publication for which to generate pages.
    * `:templates` - Should be a module providing a `Phoenix.Component` for all available pages to be rendered for the static pages. (default: `Literature.StaticPages.Templates`). See the `Literature.StaticPages.Templates` module for an example.

  ## Available Pages

  The following page types can be generated by this module (use the `:only` option to select):

    * `:index`        - Main index page with no pagination.
    * `:index_page`   - Paginated index pages (e.g., `/page/2`).
    * `:show_post`    - Individual post pages.
    * `:tags`         - Tag listing and tag-specific post pages.
    * `:authors`      - Author listing and author-specific post pages.

  ## Injected Functions
  The module injects the following functions into the caller:

    * `generate_all/1` - Generates all specified static pages for the publication.
    * `generate/2` - Generates a specific static page type for the publication, given the page type and current URL.

  `current_url` must be provided to generate the correct links inside the pages.

  ## Provided Functions

    * `store_path/2` - Computes the output directory for static files.
    * `generate_file/3` - Writes rendered static page inside `store_path`.

  ## Example

      generate(:index, "https://example.com")

  This will generate an `index.html` file for the publication at the appropriate static path, "https://example.com/en/blog/index.html"
  """

  defmacro __using__(opts) do
    pages = Keyword.get(opts, :only, ~w(index tags authors show)a)
    page_size = Keyword.get(opts, :page_size, 10)
    path = Keyword.get(opts, :path, "/")

    publication_slug =
      Keyword.get_lazy(opts, :publication_slug, fn ->
        raise "Missing mandatory :publication_slug option."
      end)

    templates = Keyword.get(opts, :templates, Literature.StaticPages.Templates)

    quote bind_quoted: binding() do
      require Logger

      import Literature.StaticPages.Generator
      import Literature.StaticPages.Helpers
      import Literature.StaticPages.MetaTagHelpers

      def generate_all(current_url) do
        for page <- unquote(pages) do
          generate(page, current_url)
        end
      end

      if :index in pages do
        def generate(:index, current_url) do
          check_for_template!(unquote(templates), :index_page)

          publication = get_publication!(unquote(publication_slug))
          store_path = store_path(unquote(path), publication.slug)
          File.mkdir_p!(store_path)

          generate_file(
            "index.html",
            store_path,
            unquote(templates).index(%{
              posts: list_published_posts(publication.slug),
              publication: publication,
              current_url: current_url
            })
          )
          |> format_result(publication.slug, "/#{publication.slug}/index.html")
        end
      end

      if :index_page in pages do
        def generate(:index_page, current_url) do
          check_for_template!(unquote(templates), :index_page)

          publication = get_publication!(unquote(publication_slug))
          page_1 = paginate_published_posts(publication.slug, 1, unquote(page_size))

          store_path = store_path(unquote(path), publication.slug)
          page_1_path = Path.join(store_path, "/page/1")
          File.mkdir_p!(page_1_path)

          generate_file(
            "index.html",
            page_1_path,
            unquote(templates).index_page(%{
              page: page_1,
              publication: publication,
              current_url: current_url
            })
          )
          |> format_result(publication.slug, "/#{publication.slug}/page/1/index.html")

          if page_1.total_pages > 1 do
            for page_number <- 2..page_1.total_pages do
              page = paginate_published_posts(publication.slug, page_number, unquote(page_size))
              page_path = Path.join(store_path, "/page/#{page_number}")
              File.mkdir_p!(page_path)

              generate_file(
                "index.html",
                page_path,
                unquote(templates).index_page(%{
                  page: page,
                  publication: publication,
                  current_url: current_url
                })
              )
              |> format_result(
                publication.slug,
                "/#{publication.slug}/page/#{page_number}/index.html"
              )
            end
          end
        end
      end
    end
  end

  @doc """
  Returns the output directory for static files. Results to `priv/static/<path>/<publication_slug>`.
  """
  @spec store_path(String.t(), String.t()) :: String.t()
  def store_path(path, publication_slug) do
    otp_app = Application.get_env(:literature, :otp_app)
    priv_dir = :code.priv_dir(otp_app)

    Path.join([priv_dir, "static", path, publication_slug])
  end

  @doc """
  Writes rendered HTML content to a file within the given static output directory.
  """
  @spec generate_file(String.t(), String.t(), Phoenix.HTML.Safe.t()) :: :ok | {:error, term()}
  def generate_file(file_name, store_path, rendered) do
    safe = Phoenix.HTML.Safe.to_iodata(rendered)
    output = Path.join([store_path, file_name])
    File.write(output, safe)
  end
end
