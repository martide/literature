defmodule Literature.StaticPages.Generator do
  @moduledoc """
  Defines a static page generator for a given publication.
  Provides a set of functions to automate the generation of static pages such as index,
  paginated index, tags, authors, and show pages(see `Available Pages`).
  It supports customization through options like pagination size, output path, and custom templates.
  Static pages are stored in the `static_pages_storage_dir` Literature config.

  ## Functions
    * `generate_all/2` - Generates all specified static pages for the publication.
    * `generate/2` - Generates a specific static page type for the publication, given the page type options.
    * `generate/3` - Generates a specific post, author or tag show page, given the resource slug.
    * `store_path/2` - Returns the output directory for the generated files inside `priv/static`.
    * `generate_file/4` - Writes rendered static page to memory or to a file inside `store_path`.

  ## Options for `generate/2` and `generate_all/2`
    * `:publication_slug` (required) - The slug of the publication for which to generate pages.
    * `:base_url` (required) - URL used inside the pages for links, pagination, and SEO tags.
    * `:page_size` - Number of posts per page for paginated pages (default: `10`).
    * `:path` - Base path for generated static files (default: `"/"`).
    * `:templates` - a module providing `Phoenix.Component` for each page listed in `Available Pages`
                     e.g. `index/1`, `index_page/1`, etc. (default: `Literature.StaticPages.Templates`).
                     See the `Literature.StaticPages.Templates` module for Behaviour and example.
    * `write_to` - Specifies where to write the generated files. Can be `:memory`(default) or `:file`. Returns `Phoenix.HTML.Safe.t()` when writing to memory.

  ## Available Pages

  The following page types can be generated by this module:

    * `:index`        - Main index page for posts with no pagination. (e.g., `/en/blog/index.html`).
    * `:index_page`   - Paginated index pages for posts (e.g., `/en/blog/page/<page_number>/index.html`).
    * `:show_post`    - Show page for specific post. (e.g., `/en/blog/<post.slug>/index.html`).
    * `:tags`         - Index page for tags. (e.g., `/en/blog/tags/index.html`)
    * `:show_tag`     - Show page for a specific tag (e.g., `/en/blog/tags/<tag.slug>.html`).
    * `:authors`      - Index page for authors. (e.g., `/en/blog/authors/index.html`)
    * `:show_author`  - Show page for a specific author (e.g., `/en/blog/authors/<author.slug>.html`).

  ## Usage

      alias Literature.StaticPages.Generator

      @opts [
        page_size: 10,
        path: "/en",
        publication_slug: "blog",
        templates: Literature.StaticPages.Templates,
        base_url: "https://example.com"
      ]

      def generate_blog_pages(pubication_slug) do
        Generator.generate(:index, @opts)
        Generator.generate(:show_post, @opts)
        Generator.generate(:authors, @opts)
        Generator.generate(:tags, @opts)
        ...

      end

      def generate_all do
        Generator.generate_all([:index_page, :authors], @opts)
      end
  """
  import Literature.StaticPages.Helpers
  import Literature.StaticPages.MetaTagHelpers

  alias Phoenix.HTML.Safe

  @type page_type ::
          :index
          | :index_page
          | :show_post
          | :authors
          | :show_author
          | :tags
          | :show_tag

  @type write_to :: :file | :memory

  @default_page_size 10
  @default_templates Literature.StaticPages.Templates
  @default_path "/"
  @default_write_to :memory

  @spec generate_all([page_type()], keyword()) :: :ok | {:ok, list()}
  def generate_all(page_types, opts) do
    results =
      async!(
        page_types,
        fn page_type -> generate(page_type, opts) end,
        timeout: :infinity
      )

    write_to = Keyword.get(opts, :write_to, @default_write_to)

    if write_to == :memory do
      {:ok,
       results
       |> Enum.map(fn {:ok, result} -> result end)
       |> List.flatten()}
    else
      :ok
    end
  end

  @spec generate(page_type :: page_type(), keyword()) :: :ok | {:ok, list()}
  def generate(:index, opts) do
    %{
      publication_slug: publication_slug,
      base_url: base_url,
      templates: templates,
      path: path,
      write_to: write_to
    } = get_options(opts)

    check_for_template!(templates, :index)

    publication = get_publication!(publication_slug)
    store_path = store_path(path)

    file_path = Path.join(path, "/index.html")

    generate_file(
      "index.html",
      store_path,
      templates.index(%{
        __changed__: %{},
        posts: list_published_posts(publication.slug),
        publication: publication,
        current_url: Path.join(base_url, file_path),
        meta_tags: get_default_meta_tags(publication, publication)
      }),
      write_to
    )
    |> format_result(publication.slug, file_path)
  end

  def generate(:index_page, opts) do
    %{
      publication_slug: publication_slug,
      base_url: base_url,
      page_size: page_size,
      templates: templates,
      path: path,
      write_to: write_to
    } = get_options(opts)

    check_for_template!(templates, :index_page)

    publication = get_publication!(publication_slug)
    page_1 = paginate_published_posts(publication.slug, 1, page_size)

    store_path = store_path(path)

    page_1_path = Path.join(store_path, "/page/1")
    file_path_1 = Path.join(path, "/page/1/index.html")

    page_1_results =
      generate_file(
        "index.html",
        page_1_path,
        templates.index_page(%{
          __changed__: %{},
          page: page_1,
          publication: publication,
          current_url: Path.join(base_url, file_path_1),
          meta_tags: get_default_meta_tags(publication, publication, page_1)
        }),
        write_to
      )
      |> format_result(publication.slug, file_path_1)

    pages =
      if page_1.total_pages > 1 do
        async!(
          2..page_1.total_pages,
          fn page_number ->
            page = paginate_published_posts(publication.slug, page_number, page_size)
            page_path = Path.join(store_path, "/page/#{page_number}")

            file_path = Path.join(path, "/page/#{page_number}/index.html")

            generate_file(
              "index.html",
              page_path,
              templates.index_page(%{
                __changed__: %{},
                page: page,
                publication: publication,
                current_url: Path.join(base_url, file_path),
                meta_tags: get_default_meta_tags(publication, publication, page)
              }),
              write_to
            )
            |> format_result(publication.slug, file_path)
          end,
          timeout: :infinity
        )
      else
        []
      end

    maybe_collect_file_tuples([page_1_results] ++ pages, write_to)
  end

  def generate(:show_post, opts) do
    %{
      publication_slug: publication_slug,
      base_url: base_url,
      templates: templates,
      path: path,
      write_to: write_to
    } = get_options(opts)

    check_for_template!(templates, :show_post)

    publication = get_publication!(publication_slug)
    store_path = store_path(path)

    posts =
      publication.slug
      |> list_published_posts()
      |> async!(
        fn post ->
          file_path = Path.join(path, "/#{post.slug}.html")

          generate_post(%{
            publication: publication,
            post: post,
            base_url: base_url,
            templates: templates,
            store_path: store_path,
            file_path: file_path,
            write_to: write_to
          })
        end,
        timeout: :infinity
      )

    maybe_collect_file_tuples(posts, write_to)
  end

  def generate(:authors, opts) do
    %{
      publication_slug: publication_slug,
      base_url: base_url,
      templates: templates,
      path: path,
      write_to: write_to
    } = get_options(opts)

    check_for_template!(templates, :authors)

    publication = get_publication!(publication_slug)
    store_path = store_path(path)
    authors_path = Path.join(store_path, "/authors")

    file_path = Path.join(path, "/authors/index.html")

    generate_file(
      "index.html",
      authors_path,
      templates.authors(%{
        __changed__: %{},
        authors: list_authors(publication.slug),
        publication: publication,
        current_url: Path.join(base_url, file_path),
        meta_tags: get_default_meta_tags(publication, publication)
      }),
      write_to
    )
    |> format_result(publication.slug, file_path)
  end

  def generate(:show_author, opts) do
    %{
      publication_slug: publication_slug,
      base_url: base_url,
      templates: templates,
      path: path,
      write_to: write_to
    } = get_options(opts)

    check_for_template!(templates, :show_author)

    publication = get_publication!(publication_slug)
    store_path = store_path(path)
    authors_path = Path.join(store_path, "/authors")

    authors =
      publication.slug
      |> list_authors()
      |> async!(
        fn author ->
          file_path = Path.join(path, "/authors/#{author.slug}.html")

          generate_author(%{
            publication: publication,
            author: author,
            base_url: base_url,
            templates: templates,
            authors_path: authors_path,
            file_path: file_path,
            write_to: write_to
          })
        end,
        timeout: :infinity
      )

    maybe_collect_file_tuples(authors, write_to)
  end

  def generate(:tags, opts) do
    %{
      publication_slug: publication_slug,
      base_url: base_url,
      templates: templates,
      path: path,
      write_to: write_to
    } = get_options(opts)

    check_for_template!(templates, :tags)

    publication = get_publication!(publication_slug)
    store_path = store_path(path)
    tags_path = Path.join(store_path, "/tags")

    file_path = Path.join(path, "/tags/index.html")

    generate_file(
      "index.html",
      tags_path,
      templates.tags(%{
        __changed__: %{},
        tags: list_public_tags(publication.slug),
        publication: publication,
        current_url: Path.join(base_url, file_path),
        meta_tags: get_default_meta_tags(publication, publication)
      }),
      write_to
    )
    |> format_result(publication.slug, file_path)
  end

  def generate(:show_tag, opts) do
    %{
      publication_slug: publication_slug,
      base_url: base_url,
      templates: templates,
      path: path,
      write_to: write_to
    } = get_options(opts)

    check_for_template!(templates, :show_tag)

    publication = get_publication!(publication_slug)
    store_path = store_path(path)
    tags_path = Path.join(store_path, "/tags")

    tags =
      publication.slug
      |> list_public_tags()
      |> async!(
        fn tag ->
          file_path = Path.join(path, "/tags/#{tag.slug}.html")

          generate_tag(%{
            publication: publication,
            tag: tag,
            base_url: base_url,
            templates: templates,
            tags_path: tags_path,
            file_path: file_path,
            write_to: write_to
          })
        end,
        timeout: :infinity
      )

    maybe_collect_file_tuples(tags, write_to)
  end

  @spec generate(:show_post | :show_tag | :show_author, String.t(), keyword()) ::
          :ok | {:ok, list()}
  def generate(:show_post, post_slug, opts) do
    %{
      publication_slug: publication_slug,
      base_url: base_url,
      templates: templates,
      path: path,
      write_to: write_to
    } = get_options(opts)

    check_for_template!(templates, :show_post)

    publication = get_publication!(publication_slug)
    post = get_post!(post_slug, publication_slug)
    store_path = store_path(path)

    file_path = Path.join(path, "/#{post.slug}.html")

    generate_post(%{
      publication: publication,
      post: post,
      base_url: base_url,
      templates: templates,
      store_path: store_path,
      file_path: file_path,
      write_to: write_to
    })
  end

  def generate(:show_author, author_slug, opts) do
    %{
      publication_slug: publication_slug,
      base_url: base_url,
      templates: templates,
      path: path,
      write_to: write_to
    } = get_options(opts)

    check_for_template!(templates, :show_author)

    publication = get_publication!(publication_slug)
    author = get_author!(author_slug, publication_slug)
    store_path = store_path(path)
    authors_path = Path.join(store_path, "/authors")

    file_path = Path.join(path, "/authors/#{author.slug}.html")

    generate_author(%{
      publication: publication,
      author: author,
      base_url: base_url,
      templates: templates,
      authors_path: authors_path,
      file_path: file_path,
      write_to: write_to
    })
  end

  def generate(:show_tag, tag_slug, opts) do
    %{
      publication_slug: publication_slug,
      base_url: base_url,
      templates: templates,
      path: path,
      write_to: write_to
    } = get_options(opts)

    check_for_template!(templates, :show_tag)

    publication = get_publication!(publication_slug)
    tag = get_tag!(tag_slug, publication_slug)

    store_path = store_path(path)
    tags_path = Path.join(store_path, "/tags")

    file_path = Path.join(path, "/tags/#{tag.slug}.html")

    generate_tag(%{
      publication: publication,
      tag: tag,
      base_url: base_url,
      templates: templates,
      tags_path: tags_path,
      file_path: file_path,
      write_to: write_to
    })
  end

  defp generate_post(%{
         publication: publication,
         post: post,
         base_url: base_url,
         templates: templates,
         store_path: store_path,
         file_path: file_path,
         write_to: write_to
       }) do
    generate_file(
      "#{post.slug}.html",
      store_path,
      templates.show_post(%{
        __changed__: %{},
        post: post,
        publication: publication,
        current_url: Path.join(base_url, file_path),
        meta_tags: get_default_meta_tags(post, publication)
      }),
      write_to
    )
    |> format_result(publication.slug, file_path)
  end

  defp generate_author(%{
         publication: publication,
         author: author,
         base_url: base_url,
         templates: templates,
         authors_path: authors_path,
         file_path: file_path,
         write_to: write_to
       }) do
    generate_file(
      "#{author.slug}.html",
      authors_path,
      templates.show_author(%{
        __changed__: %{},
        author: author,
        publication: publication,
        current_url: Path.join(base_url, file_path),
        meta_tags: get_default_meta_tags(author, publication)
      }),
      write_to
    )
    |> format_result(publication.slug, file_path)
  end

  defp generate_tag(%{
         publication: publication,
         tag: tag,
         base_url: base_url,
         templates: templates,
         tags_path: tags_path,
         file_path: file_path,
         write_to: write_to
       }) do
    generate_file(
      "#{tag.slug}.html",
      tags_path,
      templates.show_tag(%{
        __changed__: %{},
        tag: tag,
        publication: publication,
        current_url: Path.join(base_url, file_path),
        meta_tags: get_default_meta_tags(tag, publication)
      }),
      write_to
    )
    |> format_result(publication.slug, file_path)
  end

  defp maybe_collect_file_tuples(results, :memory) do
    {:ok, collect_files(results)}
  end

  defp maybe_collect_file_tuples(_results, _write_to), do: :ok

  defp collect_files(file_tuples) do
    Enum.map(file_tuples, fn {:ok, [file_tuple]} -> file_tuple end)
  end

  defp get_options(opts) do
    publication_slug = Keyword.fetch!(opts, :publication_slug)
    base_url = Keyword.fetch!(opts, :base_url)
    page_size = Keyword.get(opts, :page_size, @default_page_size)
    path = Keyword.get(opts, :path, @default_path)
    templates = Keyword.get(opts, :templates, @default_templates)
    write_to = Keyword.get(opts, :write_to, @default_write_to)

    binding()
    |> Map.new()
  end

  @doc """
  Returns the output directory for static files.
  """
  @spec store_path(String.t()) :: String.t()
  def store_path(path) do
    storage_dir = Application.get_env(:literature, :static_pages_storage_dir)

    Path.join(storage_dir, path)
  end

  @doc """
  Writes rendered HTML content to a file within the given static output directory.
  """
  @spec generate_file(String.t(), String.t(), Safe.t(), write_to()) ::
          :ok | {:ok, tuple()} | {:error, term()}
  def generate_file(file_name, store_path, rendered, write_to) do
    safe = Safe.to_iodata(rendered)
    output = Path.join([store_path, file_name])

    case write_to do
      :memory ->
        {:ok, {output, safe}}

      :file ->
        File.mkdir_p!(store_path)

        # https://hexdocs.pm/elixir/1.14.5/File.html#write/3
        # Use File.open/3 to write to the file since this can be called in a loop
        File.open(output, [:write, :binary], fn file ->
          IO.binwrite(file, safe)
        end)
    end
  end
end
