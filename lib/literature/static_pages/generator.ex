defmodule Literature.StaticPages.Generator do
  @moduledoc """
  Defines a static page generator for a given publication.
  Provides a set of functions to automate the generation of static pages such as index,
  paginated index, tags, authors, and show pages(see `Available Pages`).
  It supports customization through options like pagination size, output path, and custom templates.
  Static pages are stored in the `priv/static` directory of the application.

  ## Functions
    * `generate_all/2` - Generates all specified static pages for the publication.
    * `generate/2` - Generates a specific static page type for the publication, given the page type options.
    * `store_path/2` - Computes the output directory for static files.
    * `generate_file/3` - Writes rendered static page inside `store_path`.

  ## Options for `generate/2` and `generate_all/2`
    * `:publication_slug` (required) - The slug of the publication for which to generate pages.
    * `:current_url` (required) - URL used inside the pages for links, pagination, and SEO tags.
    * `:page_size` - Number of posts per page for paginated pages (default: `10`).
    * `:path` - Base path for generated static files (default: `"/"`).
    * `:templates` - a module providing `Phoenix.Component` for each page listed in `Available Pages`
                     e.g. `index/1`, `index_page/1`, etc. (default: `Literature.StaticPages.Templates`).
                     See the `Literature.StaticPages.Templates` module for example.

  ## Available Pages

  The following page types can be generated by this module:

    * `:index`        - Main index page for posts with no pagination. (e.g., `/en/blog/index.html`).
    * `:index_page`   - Paginated index pages for posts (e.g., `/en/blog/page/<page_number>/index.html`).
    * `:show_post`    - Show page for specific post. (e.g., `/en/blog/<post.slug>/index.html`).
    * `:tags`         - Index page for tags. (e.g., `/en/blog/tags/index.html`)
    * `:show_tag`     - Show page for a specific tag (e.g., `/en/blog/tags/<tag.slug>.html`).
    * `:authors`      - Index page for authors. (e.g., `/en/blog/authors/index.html`)
    * `:show_author`  - Show page for a specific author (e.g., `/en/blog/authors/<author.slug>.html`).

  ## Usage

      alias Literature.StaticPages.Generator

      @opts [
        page_size: 10,
        path: "/en",
        publication_slug: "blog",
        templates: Literature.StaticPages.Templates,
        current_url: "https://example.com"
      ]

      def generate_blog_pages(pubication_slug) do
        Generator.generate(:index, @opts)
        Generator.generate(:show_post, @opts)
        Generator.generate(:authors, @opts)
        Generator.generate(:tags, @opts)
        ...

      end

      def generate_all do
        Generator.generate_all([:index_page, :authors], @opts)
      end
  """
  import Literature.StaticPages.Helpers
  import Literature.StaticPages.MetaTagHelpers

  alias Phoenix.HTML.Safe

  @default_page_size 10
  @default_templates Literature.StaticPages.Templates
  @default_path "/"

  def generate(:index, opts) do
    %{
      publication_slug: publication_slug,
      current_url: current_url,
      templates: templates,
      path: path
    } = get_options(opts)

    check_for_template!(templates, :index)

    publication = get_publication!(publication_slug)
    store_path = store_path(path, publication.slug)
    File.mkdir_p!(store_path)

    generate_file(
      "index.html",
      store_path,
      templates.index(%{
        posts: list_published_posts(publication.slug),
        publication: publication,
        current_url: current_url,
        meta_tags: get_default_meta_tags(publication)
      })
    )
    |> format_result(publication.slug, "/#{publication.slug}/index.html")
  end

  def generate(:index_page, opts) do
    %{
      publication_slug: publication_slug,
      current_url: current_url,
      page_size: page_size,
      templates: templates,
      path: path
    } = get_options(opts)

    check_for_template!(templates, :index_page)

    publication = get_publication!(publication_slug)
    page_1 = paginate_published_posts(publication.slug, 1, page_size)

    store_path = store_path(path, publication.slug)
    page_1_path = Path.join(store_path, "/page/1")
    File.mkdir_p!(page_1_path)

    generate_file(
      "index.html",
      page_1_path,
      templates.index_page(%{
        page: page_1,
        publication: publication,
        current_url: current_url,
        meta_tags: get_default_meta_tags(publication)
      })
    )
    |> format_result(publication.slug, "/#{publication.slug}/page/1/index.html")

    if page_1.total_pages > 1 do
      async!(2..page_1.total_pages, fn page_number ->
        page = paginate_published_posts(publication.slug, page_number, page_size)
        page_path = Path.join(store_path, "/page/#{page_number}")
        File.mkdir_p!(page_path)

        generate_file(
          "index.html",
          page_path,
          templates.index_page(%{
            page: page,
            publication: publication,
            current_url: current_url,
            meta_tags: get_default_meta_tags(publication)
          })
        )
        |> format_result(
          publication.slug,
          "/#{publication.slug}/page/#{page_number}/index.html"
        )
      end)
    end
  end

  def generate(:show_post, opts) do
    %{
      publication_slug: publication_slug,
      current_url: current_url,
      templates: templates,
      path: path
    } = get_options(opts)

    check_for_template!(templates, :show_post)

    publication = get_publication!(publication_slug)
    store_path = store_path(path, publication.slug)

    File.mkdir_p!(store_path)

    publication.slug
    |> list_published_posts()
    |> async!(fn post ->
      generate_file(
        "#{post.slug}.html",
        store_path,
        templates.show_post(%{
          post: post,
          publication: publication,
          current_url: current_url,
          meta_tags: get_default_meta_tags(post)
        })
      )
      |> format_result(publication.slug, "/#{publication.slug}/#{post.slug}.html")
    end)
  end

  def generate(:authors, opts) do
    %{
      publication_slug: publication_slug,
      current_url: current_url,
      templates: templates,
      path: path
    } = get_options(opts)

    check_for_template!(templates, :authors)

    publication = get_publication!(publication_slug)
    store_path = store_path(path, publication.slug)
    authors_path = Path.join(store_path, "/authors")
    File.mkdir_p!(authors_path)

    generate_file(
      "index.html",
      authors_path,
      templates.authors(%{
        authors: list_authors(publication.slug),
        publication: publication,
        current_url: current_url,
        meta_tags: get_default_meta_tags(publication)
      })
    )
    |> format_result(publication.slug, "/#{publication.slug}/authors/index.html")
  end

  defp get_options(opts) do
    publication_slug = Keyword.fetch!(opts, :publication_slug)
    current_url = Keyword.fetch!(opts, :current_url)
    page_size = Keyword.get(opts, :page_size, @default_page_size)
    path = Keyword.get(opts, :path, @default_path)
    templates = Keyword.get(opts, :templates, @default_templates)

    binding()
    |> Map.new()
  end

  @doc """
  Returns the output directory for static files. Results to `priv/static/<path>/<publication_slug>`.
  """
  @spec store_path(String.t(), String.t()) :: String.t()
  def store_path(path, publication_slug) do
    otp_app = Application.get_env(:literature, :otp_app)
    priv_dir = :code.priv_dir(otp_app)

    Path.join([priv_dir, "static", path, publication_slug])
  end

  @doc """
  Writes rendered HTML content to a file within the given static output directory.
  """
  @spec generate_file(String.t(), String.t(), Safe.t()) :: :ok | {:error, term()}
  def generate_file(file_name, store_path, rendered) do
    safe = Safe.to_iodata(rendered)
    output = Path.join([store_path, file_name])
    File.write(output, safe)
  end
end
